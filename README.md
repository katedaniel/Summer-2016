# Summer-2016

Note - At various points in these files, a filepath/filename is used to specify locations of previous files or future files. These filepaths will need to be changed for each computer using the overall files and functions.

Animated_Surface_Density.py : 
	With the qpR.npy files generated by Generate_orbit_objects.py, this file can plot animations of all of the stars in the rotating frame as well as an animation of the surface density of the star distribution. Can also produce a static plot of the surface density and any timestep.

ConciseOrbitCode.py : 
This file demonstrates how to use the Orbit_Calculator class within Orbit_Code without many comments. 

Generate_orbit_objects.py : 
This is a helper file for the Animated_Surface_Density.py in that it generates all of the qpRdata for each orbit and stores it in a 3-D numpy array with a .npy extension. This must be run for each set of qp data. Manually change the desired theta and filepath at the beginning of the program. Takes about 10 minutes or so to run.

LF_L4 / LF_L4.cpp / LF_L4.o : 
	This is the C++ code (along with its executable version) for the orbital integrator. There is a python version inside of orbit_code, but the C++ version is much much faster. It reads in x,y,vx,vy via a text file called temp_initials. The environmental variables are hard coded in. K daniel is the author and currently the only one who understands the C++ version.

MC_fNew.py : 
	This is the Monte Carlo used to generate initial conditions for the simulation. K. Daniel is the sole author and knows how it works. At the top you can specify how many batches and initials per batch to generate (1 and 1 for OSG). At the bottom you can specify how to output the data. Currently, for OSG, it will generate a single initial condition (x,y,vx,vy) and put it into a text file called temp_initials in the same folder that MC_fNew.py is in. 

MakeTable.py : 
	This file reads the raw qp data generated by OSG. It will use the os to walk through all of the tarred qp files, untar them, create orbit objects for each qp orbit, calculates some stuff, and then generates two tables through which other files can sift and access the qp data. See MakeTable for poop specifics of the tables’ information.

OrbitAnimationTest.py : 
	This file uses an Orbit_Calculator to plot an animation of one orbit, plotting the star’s path as well as that of the guiding center. This file requires the filepath to a qp to be hardcoded into the program.

OrbitDemonstration.py : 
This file demonstrates how to use the Orbit_Calculator class within Orbit_Code with detailed and thorough comments. See this file before ConciseOrbitCode.py

Orbit_Code.py / Orbit_Code.pyc : 
	This file defines the Orbit_Calculator class that is capable of integrating orbits, plotting them, and calculating other useful information about the orbits. The purpose of the class (as opposed to just a regular py file) is to be able to create an instance of the Orbit_Calculator with unique data for each qp. One must instantiate an instance of the class and either calculate the orbit (with the makeOrbit() function) or set the qp in order to use all of the other functions. See the documentation at the beginning of the file for a thorough explanation of its capabilities and how to use it. Note that anytime the Orbit_Calculator class is used in another program, it must be imported from Orbit_Code and reloaded to include any changes made to the class. Additionally, when setting the qp, note that the qp data generated by OSG puts the time column in the wrong place. So, it must be switched before setting qp. 
	
Table_Helper.py / Table_Helper.pyc: 
	This is a helper file used in the MakeTable file. It untars files from OSG, and then goes through this data to generate two tables. The tables it creates are explained below. In order to make new plots in the tableReader file, the tables will most likely have to be changed or added onto. This usually involves changing Table_Hepler and regenerating tables.

Login.csh / server.csh / TrappedOrbits.submit: 
These are files used to run the orbital integrator simulation on the OSG network. Variables for number of runs and stars per run are inside the submit file. Once logged onto the server, the submit file is the only thing necessary to explicitly run. As of now, the submit file leaves all of the simulation info in a bunch of tarred files on the login server. They must then be uploaded/downloaded/pushed to github or a computer. For detailed instructions on how to use OSG, please go ask a real person, not the README file.

nr3.h / ran.h / ode.h / svd.h : 
These are helper files used in the C++ code. Don’t mess with them. They will need to be on your computer to run the C++ code.

Table(1,2)_(15,20,25,30).txt : 
These are text files of the tables used in tableReader. They contain information about the massive amount of qp’s. The first table has individual info on each qp, including filepath (for noah’s com), initials, lambda special (see orbit_code), and change in angular momentum at various times. The second table has aggregate info on rms of change in angular momentum and number of trapped orbits at each time. Each table has four types for each theta. 

tableReader.py : 
This file starts out by reading in the table information explained above. It then has various functions that are useful for plotting (or simply stating) said information. There are three main plots it creates. Trap_plot displays the number of trapped orbits per theta over time. Each theta is separately normalized to the initial number of trapped orbits (so they all start at 1). Angmom_plot shows the rms change in angular momentum per theta over time. The solid lines track the stars that are initially trapped, and the dashed lines track the stars that are always trapped. plot_Lz displays a 4x4 plot for (4 thetas and 4 times) of the change in angular momentum based on initial angular momentum. It is a colormapped density histogram, with vertical lines representing lindblad radii (dashed), ultraharmonic radii (dotted), and corotation radius (full).
